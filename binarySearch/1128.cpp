//
/*
 * 假如直接去枚举各种分组情况，那么是指数复杂度。
假设答案是x，那么我们可以用一个循环遍历数组a，按照不超过分组，如果最终分的组数不超过k组，那么可以证明最优答案小于等于x，如果分组超过k，则证明最终答案比大。
这种解法成立，是因为单调关系的存在，本题中涉及的量无外乎段数k，各段和的最大值。如果我们定义段数<=k才算合法，就可以考虑这样一种单调关系：各段和越大，段数越少（越合法），各段和越小，段数越多（越不合法）。
因此我们二分各段和的最大值，也就是这个和的上限，不难想到可以O（n）的复杂度计算这个上限控制下能分多少段，如果段数<=K，那么合法，可以调小这个上限，反之调大。
这样最终找到一个“刚好合法”的上限，正好就是题目所求的最大值的最小值了。每次check的复杂度为0（n），二分的复杂度为O（log（m）），其中m为数据的范围，整体复杂度为O（nlogm）
 */
#include <iostream>
using namespace std;

int n, k, numbers[50005];
#define LL long long
LL low = 0, high = 1e8, answer = 0;

int main() {
  cin >> n;
  for (int i =0; i < n; i++) {
    cin >> numbers[i];
  }

  cout << binary_search(numbers, n, low, high);
}